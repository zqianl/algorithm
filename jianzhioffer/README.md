# algorithm 


### 1. 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得和为S，如果有多对数字的和等于S，输出两个数的乘积最小的。

### 2. 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

### 3. 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

### 4. 对公司所有员工的年龄进行排序，公司总共有几万名员工，要求时间复杂度为O（n）。

### 5. 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。

### 6. 输入一个整数n(1<=n<=70)，请你输出斐波那契数列的第n项。

### 7. 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

### 8. 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

### 9. 给定一个数字N，打印从1到最大的N位数。

### 10. 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

### 11. 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。
	输入：输入可能包含多个测试样例。对于每个测试案例，输入为一个合法或者非法的字符串，代表一个整数n(1<= n<=10000000)。
	输出：对应每个测试案例，若输入为一个合法的字符串(即代表一个整数)，则输出这个整数。若输入为一个非法的字符串，则输出“My God”。

### 12. 写一个函数，求两个整数之和，要求在函数体内不得使用+、-等四则运算符号。 
	输入：输入可能包含多个测试样例。对于每个测试案例，输入为两个整数m和n(1<=m,n<=1000000)。
	输出：对应每个测试案例，输出m+n的值

### 13. 求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
	输入：输入可能包含多个测试样例。对于每个测试案例，输入为两个整数m(1<=m<=1000000)。
	输出：对应每个测试案例，输出1+2+3+…+n的值

### 14. n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。 [http://blog.csdn.net/wuzhekai1985/article/details/6628491](http://blog.csdn.net/wuzhekai1985/article/details/6628491)

### 15. 一副扑克牌,发现里面居然有2个大王,2个小王。
	输入：输入有多组数据。
	每组数据包含两行,第一行输入一个正数n(0<=n<=14),表示从扑克牌中抽出的扑克牌数。接下来的一行输入n个数,表示从这幅扑克牌中抽出的牌。如果n=0,则结束输入。
	输出：对应每组数据,如果抽出的牌是顺子,则输出“So Lucky!”。否则,输出“Oh My God!”。

### 16. 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列?!

### 17. 一个整型数组里除了一个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

### 18. 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

### 19. 一个整型数组里除了三个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

### 20. 求出1-13的整数中1出现的次数,并算出100-1300的整数中1出现的次数？有两个整数a,b(0<=a,b<=1,000,000,000)，输出a和b之间1出现的次数。

### 21. 只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

### 22. 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
	输入：
	第一行输入有n，n表示结点数，结点号从1到n。根结点为1。 n <= 10。

	接下来有n行，每行有两个个整型a和b，表示第i个节点的左右孩子孩子。a为左孩子，b为右孩子。当a为-1时，没有左孩子。当b为-1时，没有右孩子。

	输出：
	输出一个整型，表示树的深度。

	样例输入：
		3
		2 3
		-1 -1
		-1 -1
	样例输出：
		2

### 23. 输入一个链表，从尾到头打印链表每个节点的值。
	输入：每个输入文件仅包含一组测试样例。每一组测试案例包含多行，每行一个大于0的整数，代表一个链表的节点。第一行是链表第一个节点的值，依次类推。当输入到-1时代表链表输入完毕。-1本身不属于链表。
	输出：对应每个测试案例，以从尾到头的顺序输出链表每个节点的值，每个值占一行。

### 24. 输入一个链表，反转链表后，输出链表的所有元素。
	输入：输入可能包含多个测试样例，输入以EOF结束。对于每个测试案例，输入的第一行为一个整数n(0<=n<=1000)：代表将要输入的链表的个数。输入的第二行包含n个整数t(0<=t<=1000000)：代表链表元素。
	输出：对应每个测试案例，以此输出链表反转后的元素，如没有元素则输出NULL。
	样例输入：5
		1 2 3 4 5  
	样例输出：5 4 3 2 1

### 25. 输入一个链表，输出该链表中倒数第k个结点。
	输入：输入可能包含多个测试样例，输入以EOF结束。对于每个测试案例，输入的第一行为两个整数n和k(0<=n<=1000, 0<=k<=1000)：n代表将要输入的链表元素的数,k代表要查询倒数第几个的元素。输入的第二行包括n个数(1<=t<=100000)代表链表中的元素。
	输出：对应每个测试案例，若有结果，输出相应的查找结果。否则，输出NULL。
	样例输入：5 2
		1 2 3 4 5
	样例输出：4

### 26. 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并输出它的后序遍历序列。

### 27. 两个栈实现一个队列
	输入：
	每个输入文件包含一个测试样例。
	对于每个测试样例，第一行输入一个n(1<=n<=100000)，代表队列操作的个数。
	接下来的n行，每行输入一个队列操作：
	1.	PUSH X 向队列中push一个整数x(x>=0)
	2.	POP 从队列中pop一个数。
	输出：
	对应每个测试案例，打印所有pop操作中从队列pop中的数字。如果执行pop操作时，队列为空，则打印-1。
	样例输入：
			3
			PUSH 10
			POP
			POP
	样例输出：
			10
			-1
### 28. 用两个队列模拟一个栈，即用两个队列的出队和入队操作，来实现栈的出栈和入栈操作。

### 29. 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
	输入：
	每个测试案例包括两行：
	第一行包含一个整数n，表示数组中的元素个数。其中1 <= n <= 10^5。
	第二行包含n个整数，每个数组均为int类型。

	输出：
	对应每个测试案例，输出一个整数，表示数组中的逆序对的总数。

	样例输入：
		4
		7 5 6 4
	样例输出：
		5

### 30. 输入一个二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

### 31. 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
	输入：
	入的第一行为两个整数m和n(0<=n<=1000, 0<=m<=1000)：n代表将要输入的第一个链表的元素的个数,m代表将要输入的第二个链表的元素的个数。

	下面一行包括n个数t(1<=t<=1000000)：代表链表一中的元素。接下来一行包含m个元素，s(1<=t<=1000000):代表链表一中的元素。

	输出：
	对应每个测试案例，
	若有结果，输出相应的链表。否则，输出NULL。

	样例输入：
		5 2
		1 3 5 7 9
		2 4
	样例输出：
		1 2 3 4 5 7 9


### 32. 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
	输入：
	输入的第一行为一个数n(0<n<1000)，代表测试样例的个数。
	接下来的n行，每行为一个二叉搜索树的先序遍历序列，其中左右子树若为空则用0代替。
	输出：
	输出将二叉搜索树转换成排序的双向链表后，从链表头至链表尾的遍历结果。
	样例输入：
	2 1 0 0 3 0 0
	样例输出：
	1 2 3

### 33.给定链表的头指针和一个结点指针，定义一个函数在O（1）时间删除该节点。

### 34.输入一个整数数组，实现一个函数来调整该数组中数字的顺序，是的所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

### 35.输入两颗二叉树A和B，判断B是不是A的子结构。

### 36.完成一个函数，输入一个二叉树，该函数输出它的镜像。

### 37.输入一个矩阵，按照从外向里以顺时针依次打印出每一个数字。

### 38.定义栈结构，在该类型中实现一个能够得到栈的最小元素的min函数，在该栈中，调用min，push及pop的时间复杂度都是O(1)。

### 39.输入两个整数序列，第一个序列表示栈的压如顺序，请判断，第二个序列是否为栈的弹出顺序。假设压入栈的所有数字均不相等。如1,2,3,4,5是压栈序列，序列4,5,3,2,1是一个弹出序列，但4,3,5,1,2则不可能是一个弹出序列。

### 40.从上到下打印二叉树，同一层从左到右打印。







	






